---
title: "Homework 3"
subtitle: "ENVS-193DS"
author: "Rebecca Martinez"
format: html
---

## Part 1. Setup Tasks

GitHub repository: https://rebeccalmartinez.github.io/ENVS-193DS_homework-03/


```{r setup, include = FALSE}

#| label: setup
#| warning: false

# Load packages 
  library(tidyverse)
  library(here)
  library(flextable)
  library(janitor)

service_data <- read_csv(here("data", "service_data.csv"))

```


## Part 2. Problems

### Problem 1. Personal data 

#### a. Data summarizing 

I could count the number of service calls where help was or wasn’t needed, grouped by whether the light was working or broken. Comparing these groups is informative because a broken light might influence whether guests mistakenly request help.

#### b. Visualizations

Code for cleaning data:

```{r data cleaning}

# Clean and standardize help and working columns

clean_service_data <- service_data |>  # using service_data set
  mutate(
    # Convert values to uppercase to avoid issues with lowercase na
    help = toupper(help),
    working = toupper(working),
    # Convert the uppercase text to logical TRUE/FALSE values
     help = as.logical(help), 
    working = as.logical(working))


```


```{r stacked bar chart}


# Create a stacked bar chart to compare how often help was or wasn't needed
# across two conditions: working lights vs broken lights
ggplot(clean_service_data, aes(x = working, fill = help)) +
  
  # Use stacked bars with slimmer width and black borders for clarity
  geom_bar(position = "stack", width = 0.6, color = "black") +
  # Add counts inside each bar segment
  geom_text(
  # Count the number of rows per group
    stat = "count",
  # Display the count as text
    aes(label = after_stat(count)),
  # Position in each stacked segment
    position = position_stack(vjust = 0.5),
  # text color and size 
   color = "black",
    size = 4
  ) +
  # Assign color to and titles to stacked bars
  scale_fill_manual(
    values = c("TRUE" = "forestgreen", "FALSE" = "red"),
    labels = c("Help Not Needed", "Help Needed")
  ) +
  
  # Replace raw logical values with clearer labels for x-axis categories
  scale_x_discrete(labels = c("TRUE" = "Working", "FALSE" = "Broken")) +
  
  # Force y-axis to start at 0 
  scale_y_continuous(limits = c(0, 50), expand = c(0, 0)) +
  
  # Set axis labels and title
  labs(
    x = "Light Condition",                   
    y = "Number of Service Calls",
    title = "Service Calls by Light Condition and Help Status"
  ) +
  
  # Apply a minimal, clean theme and customize layout
  theme_classic() +
  theme(
  # Center and bold the title
    plot.title = element_text(face = "bold", hjust = 0.5, size = 16), 
  # Bold axis labels
    axis.title = element_text(face = "bold"),                          
  # Move legend to top-right
    legend.position = c(0.95, 0.95),                                   
  # Align legend corner
    legend.justification = c("right", "top"),                          
  # Remove title
    legend.title = element_blank()                                     
  )


```


#### c. Caption

**Figure 1. False service calls were more common when the light was broken.**
Stacked bars show the number of service calls under each light condition (Working vs. Broken), split by whether help was actually needed (green) or not (red). Out of 49 broken service lights, 45 did not require help and only 4 did. Out of 43 working service lights, 32 did not require help and 11 did. An additional 16 cases had unknown light status (and are not shown in the figure (gray).



#### d. Table Presentation

```{r summary table}
#
# Create a summary table that counts how often help was or wasn’t needed,
# grouped by the condition of the service light (working, broken, or unknown)

help_summary <- clean_service_data |>
  mutate(
    # Turn the 'working' column into clear labels for light condition
    light_status = case_when(
      working == TRUE ~ "Working",
      working == FALSE ~ "Broken",
      is.na(working) ~ "Unknown"
    ),
    
    # Turn the 'help' column into clear labels for help status
    help_status = case_when(
      help == TRUE ~ "Help Needed",
      help == FALSE ~ "No Help Needed",
      is.na(help) ~ "Unknown Help"
    )
  ) |>
  
  # Count how many service calls fall into each combination of light and help status
  count(light_status, help_status) |>
  
  # Rearrange the data so each help type becomes its own column
  pivot_wider(
    names_from = help_status,
    values_from = n,
    values_fill = 0  # if a group doesn’t exist, fill it with 0
  )

# Make sure all expected help categories are included (even if not present in the data)
for (col in c("Help Needed", "No Help Needed", "Unknown Help")) {
  if (!col %in% names(help_summary)) {
    help_summary[[col]] <- 0
  }
}

# Order the rows so "Working" comes first and "Unknown" is last,
# then select and reorder columns for readability
help_summary <- help_summary |>
  mutate(light_status = factor(light_status, levels = c("Working", "Broken", "Unknown"))) |>
  arrange(light_status) |>
  select(light_status, `Help Needed`, `No Help Needed`, `Unknown Help`) |>
  
  # Add a new column that totals the calls for each light condition
  mutate(`Total Calls` = `Help Needed` + `No Help Needed` + `Unknown Help`)

# Format the summary table for display using flextable
help_summary |>
  flextable() |>
  set_header_labels(light_status = "Light Condition") |>
  autofit() |>
  set_caption("Table 1. Service calls by light condition and whether help was needed.")


```

